# Linux Installation and Package Management
---
## Design Hard Disk Layout
- Main File System Locations
  - Primary locations to know:
    - `/` | Root
    - `/var` | Logfiles and other dynamic content; variable content
    - `/home` | User's home directory where personal files are stored; every user gets their own
    - `/boot` 
    - `/opt`| short for optional and used for third-party vendors
  - Swap space
    - temp storage that acts like ram
    - when a percentage of ram is full, kernel moves less used data to swap
    - swap partition usually
    - sometimes a swap file (like page file on windows)
      - much slower than partition
    - Sizing
      - Older rule of thumb: 1.5x - 2x size of ram
      - nowadays generally don't want smaller than 50% of your ram
  - Partitions
    - `/dev/sda` -> dev directory location that contains hardware attached to system
    - sda is first connected device indicated by 'a'
  - Mount point
    - an entire partition mounted to a directory
    - like `/dev/sda2` -> `/home` ; `/dev/sda3` -> `/boot` ; `/dev/sda1` -> `/`
    - taking a partition or disk and mounting it to a directory
  - Commands
    - `mount`
      - list every partition and mount point used on the system
      - shows a lot of pseudo file systems
      - nvme -- newer systems, newest type of solid state harddrives
    - `lsblk`
      - list out block devices, basically a harddisk
    - `fdisk -l /dev/diskname`
      - need root `su -`
    - `swapon --summary`
      - Shows a summar of the swap usage on a system ,same information can be found in `/proc/swaps`
    
- Intro to LVM
  - Logical Volume Manager
  - Allows the creation of 'groups' of disks or partitions that can be assembled into a single (or multiple) filesystem(s):
    - Can be used for nearly any mount point except for /boot
      - GRUB cannot read lvm metadata
    - Flexibility -- allows for resizing of volumes
    - Snapshots - allows for 'point in time' copies of you logical volume
  - PV (Physical Volume) --> VG (Volume Group) --> LV (Logical Volumes) --> file system
  - Commands
    - pvs
      - physical volume scan
      - lists out the physical volumes in an lvm group
    - vgs
      - lists out the volume groups within an lvm group
    - lvs
      - lists out the logical volumes within an lvm group


---
## Install a Boot Manager
- Legacy Grub
  - BIOS checks everything out, then locates bootloades with `boot.img` in master boot record (mbr -- first 512 bytes of hdd) (stage 1).
  - boot.img is looking for core.img (stage 1.5) and load it. 
  - core.img purpose is to loacate `/boot/grub` (stage 2)
    - grub.conf (redhat) or menu.lst (debian) file
    - and device.map which shows were kernel and os to be booted
  - Install
    - grub-install [device] (grub-install '(hd0)'
      - findmnt /boot
        - shows actual location of where the boot partition is found
    - grub
      - find /grub/stage1 (diff than `find`)
        - (hd0,0)
    - executing `grub-install` on a system that is actively up and running is potentially dangerous
      - this step is teypically done from a live cd/usb where grub is getting installe to a new disk
  - Steps:
    - `grub` opens a new "grub shell"
      - `help`
      - `find /grub/stage1` 
      - `quit`
    
- GRUB2
  - Differnce between MBR (Master boot record) and GPT (GUID Partition Table)
    - MBR (Legacy Grub)
      - Traditionally supported only 26 total partitions (4 partitions, with one partition extended to 23 partitions)
      - Each partition limited to 2TB
    - GPT (GRUB2)
      - Supports up to 128 Partitions
      - Partition size up in the ZB (zettabyte) range (1ZB = 909,494,701.8 TB)
      - Needs UEFI
        - "Unified Extensible Firmware Interface"
        - Replacement for traditional BIOS, can act in legacy BIOS mode
        - Requires 64bit os
        - Prevents unauthorized OS from booting on the system
  - GRUB2 on GPT with UEFI
    - UEFI BIOS --> Stage 1 MBR boot.img --> GPT Header (GPT style disk) --> Partition Entry Array --> Stage 1.5 core.img --> 
    - core.img is looking for `/boot/efi` partition (has to be vfat or FAT32 file system) ("ESP")
    - stage 2 `boot/grub2` --> `grubenv` and `themes`
  - Commands
    - Red Hat Based --> grub2-<command>
    - Debian Based --> grub-<command>
    - `grub2-editenv list`
      - view the default boot entry for the grub config file
      - can modify `/etc/default/grub`
      - 
    - `grub2-mkconfig`
      - creates (or updates) a /boot/grub1/grub.cfg file based on entries from the /etc/default/grub file
    - `update-grub`
      - command that can be used to update a GRUB2 configuration after changes to /etc/default/grub have been made, found on debian based systems
     

- Interacting with the Boot Loader
  - GRUB Legacy
    - In boot menu
      - [a]
        - append options to the kernel boot line
      - [c]
        - open the GRUB command line
          - `setup (hd0)` (just rewrites the config)
      - [esc]
        - escapes out of any GRUB menu
  - GRUB2
    - [e] key
      - Used to edit a GRUB menu item
    - Ctrl+x or F10
      - Boots a selection or modified line
    -

---
## Manage Shared Libraries
- Files containing functionality that other applications can use
- End in `.so` extension
- Found in 
  - `/lib`
  - `/usr/lib` (32 bit) 
  - `/usr/lib64` (64 bit)
  - `/usr/local/lib`
  - `/usr/share`
- Two types of library files
  - Dynamic (ends in .so)
    - Type that is shared among multiple applpications in a system
  - Statically linked (ends in .a)
    - compiled for applications that need to make sure the same version of a function when a call is made 
    - Games and graphics is common
- Commands
  - `ldd </bin/cp>`
    - Prints out shared object (library) dependencies
  - `ldconfig`
    - Configures dynamic linker run-time bindings, creates a cache based on library directories and can show you what is currently cached
  - `/etc/ld.so.conf`
    - Configuratino file that points to directories and other configuration files that hold references to library directory locations
  - `LD_LIBRARY_PATH`
    - Legacy environment variable that points to a path where library files can be read from 
- 
---
## Use Debian Package Management
- Advanced Package Manager (`apt`)
  - Ubuntu, Mint, etc.
  - Installs applications and their **dependencies**. 
  - Can remove packages
  - Handles updates and upgrades
  - How it works
    - Reads `/etc/apt/sources.list`
    - Directs installation and uninstall of packages ot `dpkg`
  - Commands
    - `/etc/apt/sources.list`
      - Configuration file that lists out repository locations for packages
    - `apt-get update`
      - updates the local apt cache with a listing of packages that can be udated/upgraded and installed
    - `apt-get upgrade`
      - upgrades the package that have upgrades available
    - `apt-get install`
      - installs a package from the repositories in the sources.list file
    - `apt-get remove`
      - removes a package from the system but any config files that come with the package are left behind
    - `apt-get purge`
      - removes the package from the system and any associated configuration files
    - `apt-get dist-upgrade`
      - upgrades all packages on the system up to the next release of the distribution
    - `apt-get download`
      - downloads the package, but does not install it
    - `apt-cache search`
      - searches through your local apt cache for a package that can be intalled
    - `apt-cache show`
      - lists out basic information about a package
    - `apt-cache showpkg`
      - displays more technical information about a package


- Debian Package (dpkg)
  - Will install package but not the dependencies unless specified
  - .deb package contents:
    - application or utility
    - default config files
    - how and where to install the files that come with the package
    - listing of dependencies the package requires
  - Dependencies need to already be installed, or installed with the package
    - `apt` handles dependencies for you, dpkg does not
  - Commands: 
    - `dpkg --info`
      - displays info on a package
    - `dpkg --status`
      - same as --info, but less detail
    - `dpkg -l`
      - lists out packages that match the string provided
    - `dpkg -i`
      - installs specified package(s)
    - `dpkg -L`
      - lists out all files that were installed with a specified package
    - `dpkg -r`
      - Removes a specified package but leaves the config files behind
    - `dpkg -P`
      - Removes a specified package and also any config files that were installed with it
    - `dpkg -S`
      - searches through the package database for a file specified and lists out any mentions of the specified file or string.
    - `dpkg-reconfigure`
      - allows for the modificatgion of a package by re-running the application's config tool
  
---
## Use RPM and YUM Package Management
- The Yellowdog Updater, Modified (YUM)
  - originally used for the Yellowdog Linux distro (used in PS3)
  - Handles rpm package dependencies
  - Used on RHEL, CentOS, Scientific Linux, and older versions of Fedora
  - Yum Setup:
    - Globaly yum configuration options are set in `/etc/yum.conf`
    - Reads repository information from `/etc/yum.repos.d/`
    - Caches latest repository information in `/var/cache/yum`
  - Commands:
    - `yum update`
      - searches online repos for updated packages compared to what is currently installed on the system, upgrades packages
    - `yum search`
    - `yum info`
    - `yum list installed`
    - `yum clean all`
    - `yum install`
    - `yum remove`
      - leaves dependencies
    - `yum autoremove`
      - uninstalls package and its dependencies
    - `yum whatprovides`
      - find out what package provides a specified file name
    - `yum reinstall`
- Other RPM Package Managers:
  - Zypper
    - SUSE Linux
  - DNF - Dandified yum
    - Used on Fedora Linux distros
      - future replacement for yum in rhel
    - Uses same command syntax as yum
    
- The Red Hat Package Manager (rpm)
  - contains:
    - Application or utility
    - default config files
    - how and where to install the files that come with the package
    - listing of dependencies that the package requires
  - uses rpm database located at `/var/lib/rpm`
    - use `rpm --rebuilddb` to repair corrupted rpm database
  - Dependencies need to already be installed or installed with the package;
    - yum handles dependencies for you, rpm does not
  - COMMANDS:
    - `rpm -qpi`
      - displays info on a package
      - same info as yum
    - `rpm -qpl`
      - lists files in a package
    - `rpm -qa`
      - lists out all installed packages
    - `rpm -i`
      - installs package -- rpm -ivh gives verbose
    - `rpm -U`
      - upgrades installed package
    - `rpm -e`
      - uninstall
    - `rpm -Va`
      - verify all installed packages
    - `rpm2cpio`
      - Converts an .rpm file into a cpio archive file, often combined with the cpio command
        - `rpm2cpio some.rpm | cpio -idmv

---
## Linux as a Virtual Guest
- Virtualization
  - Vm communicates with hardware and OS with Hypervisor
  - Examples: 
    - KVM, QEMU, VMWare, Xen, VirtualBox
  - Full Virtualization
    - Guest system is not aware that it is a virtual machine
  - Paravirtualization
    - guest system is aware that it is a virtual machine, uses guest drivers
      - typically perform better
  - Can be cloned
    - may need to change a Linux system's D-Bus Machine ID
      - `dbus-uuidgen
        - ensures that each running kernel interacts with a system that has a unique id
  - Often provisioned from cloud providers
- Containers
  - Entirely isolated set of packages, libraries, and/or applications that are completely independent from their surroundings
  - Machine Container 
    - shares a kernel and file system with the host computer
  - Application Container
     - Shares everything but the application files and library files that the application needs
     - great for WEBSERVERS for quick expansion
  - Examples:
    - Docker, nspawn (from systemd), LXD, OpenShift
- Differences:
  - Virtualization
    - Invented to allow the sharing yet segregation of serer instances from each other
    - Protect one operating system from another
    - Prevention of letting spare CPU cycles, memory, or disk space go to waste
    - Based on emulating virtual hardware through a hypervisor
    - heavy in terms of system requirements
  - Containers
    - Use shard OS
    - more efficient in system resource terms
    - more granular management of system resources

---
